# 브랜치와 병합

브랜치는 나무의 가지처럼 하나의 뿌리에서 시작한 코드가 여러 갈래로 나뉘어 개발될 수 있도록 해준다.  
그리고 병합(Merge)을 통해, 각기 다른 브랜치에서 작업한 결과를 다시 하나의 코드 흐름으로 합칠 수 있다.

## 예제로 먼저 이해해 보자
![alt text](img/branch-merge-00.png)

철수와 영희가 함께 하나의 프로그램을 개발하기로 했다.

- 철수는 **main 브랜치**에서 작업하고
- 영희는 **feature 브랜치**에서 작업한다
- 형진은 **bugfix 브랜치**에서 작업한다

세 사람은 서로의 작업에 영향을 주지 않기 위해  
각자 다른 브랜치에서 코드를 수정하며 개발을 진행한다.

이후 작업이 끝나면, ***형진의 버그수정 내역과*** ***영희가 만든 기능***을 main 브랜치에 **병합(merge)** 하게 된다.

- 서로 **다른 부분을 수정했다면** 자동으로 병합됨  
- **같은 부분을 수정했다면** 충돌(conflict)이 발생하고  
  어느 쪽을 반영할지 사람이 직접 결정해야 한다  

이 “타협 과정”이 바로 **병합 충돌 해결**이다.

## 브랜치란 무엇인가? 왜 굳이 코드를 쪼개는 걸까?

브랜치(branch)는 **기존 코드 흐름에서 분기된 독립적인 작업 공간**이다.  

브랜치를 사용하는 이유는 명확하다.

- 새로운 기능 개발
- 실험적인 코드 작성
- 버그 수정

이 모든 작업을 **기존 코드에 영향을 주지 않고** 진행하기 위해서다.

브랜치를 사용하지 않는다면:
- 작업 중인 코드가 바로 메인 코드에 영향을 주고
- 실수 하나로 전체 프로젝트가 망가질 수 있다

👉 그래서 Git에서는  
**“기본은 브랜치를 나눠서 작업하고, 완성되면 병합한다”**  
라는 흐름을 권장한다.

## 병합이란 무엇인가?

병합(Merge)은 **다른 브랜치에서 작업한 변경 사항을 현재 브랜치로 가져오는 작업**이다.

예를 들어:
- 현재 브랜치: `main`
- 병합 대상 브랜치: `test`

병합의 결과는 두 가지다  
**1️⃣ 자동 병합 성공**
- 서로 다른 파일 또는 다른 줄을 수정한 경우
- Git이 알아서 합쳐준다

**2️⃣ 병합 충돌(conflict) 발생**
- 같은 파일의 같은 부분을 수정한 경우
- Git이 판단할 수 없어 사용자의 선택이 필요하다


## 주요 명령어
### git log
```sh
git log --oneline --graph --all
```
이 명령어는 모든 브랜치의 커밋 히스토리를 한눈에 시각적으로 보여준다.
필요에 따라 옵션을 주어서 확인할 것!
- --oneline : 커밋을 한 줄로 간단히 표시
- --graph : 브랜치 분기 구조를 그래프로 표현
- --all : 현재 브랜치뿐 아니라 모든 브랜치의 히스토리를 표시

---

### 브랜치 확인 및 이름 바꾸기
```sh
git branch # 1
git branch -m main # 2
```
#1. 현재 저장소에 존재하는 브랜치 목록을 출력  
`* 표시`가 붙은 브랜치가 현재 브랜치

#2. 현재 브랜치의 이름을 main으로 변경  
주로 master → main으로 변경할 때 사용

---

### 브랜치 옮기기 
```sh
git switch <branch_name>
git checkout <branch_name>
```
다른 브랜치로 작업 공간을 이동
- git switch는 브랜치 이동 전용 명령어
- git checkout은 브랜치 이동뿐 아니라 파일 복구 등 여러 기능을 포함
👉 최근에는 의도를 명확히 하기 위해 git switch 사용을 권장한다.

---

### 브랜치 병합하기
```sh
git merge <branch_name>
```
<branch_name> 브랜치의 변경 사항을 현재 브랜치로 병합하는 명령어
- 서로 다른 부분을 수정했다면 자동 병합
- 같은 부분을 수정했다면 충돌(conflict) 발생

## 예시

### 1️⃣ 초기 상태 (공통 커밋만 존재)
![alt text](img/branch-merge-01.png)

하나의 브랜치(main)에서만 개발이 진행된 상태이다.  
아직 브랜치를 나누지 않았기 때문에 모든 커밋은 하나의 직선적인 히스토리를 가진다.  
이 시점이 **브랜치를 나누기 전 기준점(base)** 이 된다.

---

### 2️⃣ test 브랜치 생성
![alt text](img/branch-merge-02.png)

`test` 브랜치를 생성한 상태이다.  
이 시점에서 `main`과 `test` 브랜치는 **같은 커밋을 가리키고 있지만**,  
이후부터는 서로 독립적으로 작업할 수 있다.

---

### 3️⃣ test 브랜치에서 작업 및 커밋
![alt text](img/branch-merge-03.png)

`test` 브랜치로 이동한 뒤 코드를 수정하고 커밋을 생성한 상태이다.  
이 커밋은 `test` 브랜치에만 존재하며,  
`main` 브랜치에는 아직 반영되지 않았다.

👉 브랜치를 나누는 목적이 **안전한 독립 작업**임을 보여주는 단계이다.

---

### 4️⃣ main 브랜치에서 별도의 작업
![alt text](img/branch-merge-04.png)

이번에는 `main` 브랜치로 돌아와 다른 수정 작업을 하고 커밋을 생성한 상태이다.  
결과적으로 `main`과 `test` 브랜치는  
**같은 기준 커밋에서 출발했지만 서로 다른 변경 이력**을 가지게 된다.

---

### 5️⃣ 병합 시 충돌 발생
![alt text](img/branch-merge-05.png)

`main` 브랜치에서 `test` 브랜치를 병합(`git merge test`)하는 과정에서  
**같은 파일의 같은 부분을 양쪽 브랜치에서 수정**했기 때문에  
Git이 자동으로 병합하지 못하고 충돌(conflict)이 발생한 상태이다.

이때 Git은:
- 어느 쪽 변경을 선택해야 할지 판단하지 않고
- 사용자가 직접 결정하도록 요청한다.

---

### 6️⃣ 충돌 해결 후 병합 완료
![alt text](img/branch-merge-06.png)

충돌이 발생한 파일을 열어:
- 불필요한 충돌 표시를 제거하고
- 원하는 코드만 남긴 뒤

`git add` → `git commit`을 수행하면  
병합이 완료되고 두 브랜치의 작업 결과가 하나로 합쳐진다.

👉 충돌 해결은 실수가 아니라, **협업 및 프로젝트 과정에서 자연스럽게 발생하는 단계**이다.
